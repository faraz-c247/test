# 🎯 RentIntel Cursor Rules - Updated Clean Code Standards

## 📁 Comprehensive Rules Structure

This project now follows a comprehensive clean code structure. Please refer to the detailed rules in the `.cursorrules/` directory:

- **Frontend Rules**: `.cursorrules/frontend/` - React, TypeScript, Next.js standards
- **Shared Standards**: `.cursorrules/shared/` - General code quality and architecture
- **Examples**: `.cursorrules/examples/` - Reference implementations

## 🚀 Updated Standards Applied

### 1. **Feature-Based Architecture**
- ✅ Created feature-based folder structure for subscriptions
- ✅ Proper separation of services, hooks, and types
- ✅ Centralized constants and error handling

### 2. **TypeScript Excellence**
- ✅ Zero tolerance for `any` types
- ✅ Comprehensive type definitions in `src/types/`
- ✅ Proper generic usage and utility types

### 3. **Constants & Configuration**
- ✅ Centralized routes in `src/constants/routes.ts`
- ✅ Error messages in `src/constants/errorMessages.ts`
- ✅ Query keys in `src/constants/queryKeys.ts`

### 4. **Error Handling**
- ✅ Centralized error handler in `src/utils/errorHandler.ts`
- ✅ Proper error types and context tracking
- ✅ Consistent API error processing

### 5. **React Query Best Practices**
- ✅ Centralized query keys with proper typing
- ✅ Feature-based service organization
- ✅ Proper error handling in hooks

### 6. **Clean Code Standards**
- ✅ Absolute imports with `@/` prefix
- ✅ Proper function naming and structure
- ✅ Performance optimizations with React.memo and useCallback

## 🎯 Quick Reference

### Import Order (enforced)
```typescript
// 1. React/Next.js imports
import React from "react";
import { NextPage } from "next";

// 2. Third-party libraries
import { useQuery } from "@tanstack/react-query";
import { toast } from "react-hot-toast";

// 3. Internal imports (absolute paths)
import { Button } from "@/components/common/Button";
import { useAuth } from "@/hooks/useAuth";
import { API_ROUTES } from "@/constants/routes";
import { handleApiError } from "@/utils/errorHandler";

// 4. Types
import type { User } from "@/types/auth";

// 5. Relative imports
import "./Component.css";
```

### Service Pattern (enforced)
```typescript
export class FeatureService {
  getAll(params: { page?: number; limit?: number }) {
    return apiClient.get(API_ROUTES.FEATURE.LIST, { params });
  }

  get({ id }: { id: string }) {
    return apiClient.get(API_ROUTES.FEATURE.DETAIL.replace(':id', id));
  }

  create(payload: CreateFeatureRequest) {
    return apiClient.post(API_ROUTES.FEATURE.LIST, payload);
  }

  update(payload: UpdateFeatureRequest) {
    return apiClient.put(API_ROUTES.FEATURE.DETAIL.replace(':id', payload.id), payload);
  }

  delete({ id }: { id: string }) {
    return apiClient.delete(API_ROUTES.FEATURE.DETAIL.replace(':id', id));
  }
}
```

### Hook Pattern (enforced)
```typescript
const FEATURE_KEY = {
  FEATURES: "features",
  FEATURE_DETAIL: "feature-detail",
};

const featureService = new FeatureService();

export const useAllFeaturesQuery = (params: { page?: number; limit?: number }) => {
  return useQuery({
    queryKey: [FEATURE_KEY.FEATURES, params],
    queryFn: () => featureService.getAll(params),
    keepPreviousData: true,
  });
};

export const useCreateFeatureMutation = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (input: CreateFeatureRequest) => featureService.create(input),
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: [FEATURE_KEY.FEATURES] });
      return data;
    },
    onError: (error) => {
      let errorMessage = "Failed to create feature";
      if (error instanceof Error) {
        errorMessage = error.message;
      }
      return errorMessage;
    },
  });
};
```

**For detailed implementation guidelines, see `.cursorrules/README.md`**

**Version**: 2.0.0 (Updated with comprehensive clean code standards)  
**Last Updated**: December 2024
